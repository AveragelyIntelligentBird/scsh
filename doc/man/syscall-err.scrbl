#lang scribble/doc
@(require scribble/manual "def-with-nolink.rkt")

@title{Errors}
@; this section is extremely out of date / touch. need to
@; A: update to talk in terms of srfi exceptions
@; B: Either link to, or (more likely) repatriate the s48 errno api.
@; repatriating is favorable so that we're not just passing integers around and are using objects
@; with a bit more info.

Scsh syscalls never return error codes, and do not use a global @code{errno} variable to report
errors. Errors are consistently reported by raising exceptions. This frees up the procedures to
return useful values, and allows the programmer to assume that
@emph{if a syscall returns, it succeeded.} This greatly simplifies the flow of the code from the
programmer's point of view.

Since Scheme does not yet have a standard exception system, the scsh definition remains somewhat
vague on the actual form of exceptions and exception handlers. When a standard exception system is
defined, scsh will move to it. For now, scsh uses the scm exception system, with a simple sugaring
on top to hide the details in the common case.

System call error exceptions contain the Unix @code{errno} code reported by the system call. Unlike
C, the @code{errno} value is a part of the exception packet, it is @emph{not} accessed through a
global variable.

For reference purposes, the Unix @code{errno} numbers are bound to the variables @code{errno/perm},
@code{errno/noent}, etc. System calls never return \@code{error/intr}---they automatically retry.

@; update this function and this section to use legit errnos.
@defproc/nolink[(errno-error [errno integer?] [syscall string?] [data any/c] ...) any]{
Raises a Unix error exception for Unix error number @var{errno}. The @var{syscall} and @var{data}
arguments are packaged up in the exception packet passed to the exception handler.
}

@deftogether[(@defform/nolink[(with-errno-handler handler-spec ... body)]
              @defproc/nolink[(with-errno-handler* [handler (-> integer? (listof any/c) (values any/c ...))]
                                                              [thunk (-> (values any/c ...))])
                       (values any/c ...)])]{
Unix syscalls raise error exceptions by calling @code{errno-error}. Programs can use
@code{with-errno-handler*} to establish handlers for these exceptions.

If a Unix error arises while @var{thunk} is executing, @var{handler} is called on two arguments
like this:

@codeblock{(handler errno packet)}

@var{packet} is a list of the form

@codeblock{(errno-msg syscall data ...)}

where @var{errno-msg} is the standard Unix error message for the error, @var{syscall} is the
procedure that generated the error, and @var{data} is a list of information generated by the error,
which varies from syscall to syscall.

If @var{handler} returns, the handler search continues upwards. @var{handler} can acquire the
exception by invoking a saved continuation. This procedure can be sugared over with the following
syntax:

@codeblock{(with-errno-handler
                 ((errno packet) clause ...)
             body ...+)}

This form executes the body forms with a particular errno handler installed. When an errno error is
raised, the handler search machinery will bind variable @var{errno} to the error's integer code, and
variable @var{packet} to the error's auxiliary data packet. Then, the clauses will be checked for a
match. The first clause that matches is executed, and its value is the value of the entire
@code{with-errno-handler} form. If no clause matches, the handler search continues.

Error clauses have two forms

@codeblock{((errno ...) body ...)
           (else body ...)}

In the first type of clause, the @var{errno} forms are integer expressions. They are evaluated and
compared to the error's errno value. An @code{else} clause matches any errno value. Note that the
@var{errno} and @var{data} variables are lexically visible to the error clauses.

Example:

@codeblock{(with-errno-handler
                ((errno packet) ; Only handle 3 particular errors.
                 ((errno/wouldblock errno/again)
                   (loop))
                 ((errno/acces)
                   (format #t "Not allowed access!")
                   #f))

             (foo frobbotz)
             (blatz garglemumph))}

It is not defined what dynamic context the handler executes in, so fluid variables cannot reliably
be referenced.
@; ^ check exception srfi to see if this is specified.

Note that Scsh system calls always retry when interrupted, so that the @code{errno/intr} exception
is never raised. If the programmer wishes to abort a system call on an interrupt, he should have the
interrupt handler explicitly raise an exception or invoke a stored continuation to throw out of the
system call.
}

@section{Interactive Mode and Error Handling}
Scsh runs in two modes: interactive and script mode. It starts up in interactive mode if the scsh
interpreter is started up with no script argument. Otherwise, scsh starts up in script mode.  The
mode determines whether scsh prints prompts in between reading and evaluating forms, and it affects
the default error handler. In interactive mode, the default error handler will report the error, and
generate an interactive breakpoint so that the user can interact with the system to examine, fix, or
dismiss from the error. In script mode, the default error handler causes the scsh process to exit.

When scsh forks a child with @code{(fork)}, the child resets to script mode.
This can be overridden if the programmer wishes.