#lang scribble/manual

@(require "def-with-nolink.rkt")

@title{System Calls}
Scsh provides (almost) complete access to the basic Unix kernel services: processes, files, signals
and so forth.  These procedures comprise a Scheme binding for Posix, with a few of the more standard
extensions thrown in (e.g., symbolic links, @code{fchown}, @code{fstat}, sockets).

@section{Errors}
@; this section is extremely out of date / touch. need to
@; A: update to talk in terms of srfi exceptions
@; B: Either link to, or (more likely) repatriate the s48 errno api.
@; repatriating is favorable so that we're not just passing integers around and are using objects
@; with a bit more info.
Scsh syscalls never return error codes, and do not use a global @code{errno} variable to report
errors. Errors are consistently reported by raising exceptions. This frees up the procedures to
return useful values, and allows the programmer to assume that
@emph{if a syscall returns, it succeeded.} This greatly simplifies the flow of the code from the
programmer's point of view.

Since Scheme does not yet have a standard exception system, the scsh definition remains somewhat
vague on the actual form of exceptions and exception handlers. When a standard exception system is
defined, scsh will move to it. For now, scsh uses the scm exception system, with a simple sugaring
on top to hide the details in the common case.

System call error exceptions contain the Unix @code{errno} code reported by the system call. Unlike
C, the @code{errno} value is a part of the exception packet, it is @emph{not} accessed through a
global variable.

For reference purposes, the Unix @code{errno} numbers are bound to the variables @code{errno/perm},
@code{errno/noent}, etc. System calls never return \@code{error/intr}---they automatically retry.

@; update this function and this section to use legit errnos.
@defproc/nolink[(errno-error [errno integer?] [syscall string?] [data any/c] ...) any]{
Raises a Unix error exception for Unix error number @var{errno}. The @var{syscall} and @var{data}
arguments are packaged up in the exception packet passed to the exception handler.
}

@deftogether[(@defform/nolink[(with-errno-handler handler-spec ... body)]
              @defproc/nolink[(with-errno-handler* [handler (-> integer? (listof any/c) (values any/c ...))]
                                                              [thunk (-> (values any/c ...))])
                       (values any/c ...)])]{
Unix syscalls raise error exceptions by calling @code{errno-error}. Programs can use
@code{with-errno-handler*} to establish handlers for these exceptions.

If a Unix error arises while @var{thunk} is executing, @var{handler} is called on two arguments
like this:

@codeblock{(handler errno packet)}

@var{packet} is a list of the form

@codeblock{(errno-msg syscall data ...)}

where @var{errno-msg} is the standard Unix error message for the error, @var{syscall} is the
procedure that generated the error, and @var{data} is a list of information generated by the error,
which varies from syscall to syscall.

If @var{handler} returns, the handler search continues upwards. @var{handler} can acquire the
exception by invoking a saved continuation. This procedure can be sugared over with the following
syntax:

@codeblock{(with-errno-handler
                 ((errno packet) clause ...)
             body ...+)}

This form executes the body forms with a particular errno handler installed. When an errno error is
raised, the handler search machinery will bind variable @var{errno} to the error's integer code, and
variable @var{packet} to the error's auxiliary data packet. Then, the clauses will be checked for a
match. The first clause that matches is executed, and its value is the value of the entire
@code{with-errno-handler} form. If no clause matches, the handler search continues.

Error clauses have two forms

@codeblock{((errno ...) body ...)
           (else body ...)}

In the first type of clause, the @var{errno} forms are integer expressions. They are evaluated and
compared to the error's errno value. An @code{else} clause matches any errno value. Note that the
@var{errno} and @var{data} variables are lexically visible to the error clauses.

Example:

@codeblock{(with-errno-handler
                ((errno packet) ; Only handle 3 particular errors.
                 ((errno/wouldblock errno/again)
                   (loop))
                 ((errno/acces)
                   (format #t "Not allowed access!")
                   #f))

             (foo frobbotz)
             (blatz garglemumph))}

It is not defined what dynamic context the handler executes in, so fluid variables cannot reliably
be referenced.
@; ^ check exception srfi to see if this is specified.

Note that Scsh system calls always retry when interrupted, so that the @code{errno/intr} exception
is never raised. If the programmer wishes to abort a system call on an interrupt, he should have the
interrupt handler explicitly raise an exception or invoke a stored continuation to throw out of the
system call.
}

@subsection{Interactive Mode and Error Handling}
Scsh runs in two modes: interactive and script mode. It starts up in interactive mode if the scsh
interpreter is started up with no script argument. Otherwise, scsh starts up in script mode.  The
mode determines whether scsh prints prompts in between reading and evaluating forms, and it affects
the default error handler. In interactive mode, the default error handler will report the error, and
generate an interactive breakpoint so that the user can interact with the system to examine, fix, or
dismiss from the error. In script mode, the default error handler causes the scsh process to exit.

When scsh forks a child with @code{(fork)}, the child resets to script mode.
This can be overridden if the programmer wishes.

@section{I/O}

@subsection{Standard RnRS I/O Procedures}
In scsh, most standard RnRS I/O operations (such as @code{display} or @code{read-char}) work on both
integer file descriptors and Scheme ports. When doing I/O with a file descriptor, the I/O operation
is done directly on the file, bypassing any buffered data that may have accumulated in an associated
port. Note that character-at-a-time operations such as @code{read-char} are likely to be quite slow
when performed directly upon file descriptors.

The standard RnRS procedures @code{read-char}, @code{char-ready?}, @code{write}, @code{display},
@code{newline}, and @code{write-char} are all generic, accepting integer file descriptor arguments
as well as ports. Scsh also mandates the availability of @code{format}, and further requires
@code{format} to accept file descriptor arguments as well as ports.

The procedures @code{peek-char} and @code{read} do @emph{not} accept file descriptor arguments,
since these functions require the ability to read ahead in the input stream, a feature not supported
by Unix I/O.

@subsection{Port Manipulation and Standard Ports}
@defproc/nolink[(close-after [port port?] [consumer (-> port? any)]) any]{
Returns @code{(consumer port)}, but closes the port on return. No dynamic-wind magic.
}

@defproc/nolink[(error-output-port) port?]{
This procedure is analogous to @code{current-output-port}, but produces a port used for error
messages---the scsh equivalent of stderr.
}

@deftogether[(@defproc/nolink[(with-current-input-port* [port port?] [thunk (-> any)]) any]
              @defproc/nolink[(with-current-output-port* [port port?] [thunk (-> any)]) any]
              @defproc/nolink[(with-error-output-port* [port port?] [thunk (-> any)]) any])]{
These procedures install @var{port} as the current input, current output, and error output port,
respectively, for the duration of a call to @var{thunk} and return @var{thunk}'s value(s).
}

@deftogether[(@defform/nolink[(with-current-input-port port body ...+)]
              @defform/nolink[(with-current-output-port port body ...+)]
              @defform/nolink[(with-error-output-port port body ...+)])]{
These special forms are simply syntactic sugar for the @code{with-current-input-port*} procedure and
friends.
}

@defproc/nolink[(close [fd/port (or/c integer? port?)]) boolean?]{
Closes the port or file descriptor.

If @var{fd/port} is a file descriptor, and it has a port allocated to it, the port is shifted to a
new file descriptor created with @code{(dup fd/port)} before closing @code{fd/port}. The port then
has its revealed count set to zero.  This reflects the design criteria that ports are not associated
with file descriptors, but with the streams they denote.

To close a file descriptor, and any associated port it might have, you must instead say one of
(as appropriate):

@codeblock{(close (fdes->inport  fd))
           (close (fdes->outport fd))}

The procedure returns true if it closed an open port. If the port was already closed, it returns
false; this is not an error.
}

@defproc/nolink[(stdports->stdio) undefined]{
Synchronises Unix' standard I/O file descriptors and Scheme's current I/O ports. Causes the standard
I/O file descriptors (0, 1, and 2) take their values from the current I/O ports. It is exactly
equivalent to the series of redirections:

@codeblock{(dup (current-input-port)  0)
           (dup (current-output-port) 1)
           (dup (error-output-port)   2)}

@margin-note{Why not @code{move->fdes}? Because the current output port and error port might be the
same port.}
}

@deftogether[(@defproc/nolink[(with-stdio-ports* [thunk (-> any)]) any]
              @defform/nolink[(with-stdio-ports body ...+)])]{
@code{with-stdio-ports*} binds the standard ports @code{(current-input-port)},
@code{(current-output-port)}, and @code{(error-output-port)} to be ports on file descriptors 0, 1,
2, and then calls @var{thunk}. It is equivalent to:

@codeblock{(with-current-input-port (fdes->inport 0)
             (with-current-output-port (fdes->inport 1)
               (with-error-output-port (fdes->outport 2)
                 (thunk))))}

The @code{with-stdio-ports} special form is merely syntactic sugar.
}

@subsection{String ports}
Scheme48 has string ports, which you can use. Scsh has not committed to the particular interface or
names that scheme48 uses, so be warned that the interface described herein may be liable to change.
@; ^ isn't there a SRFI for this? change wording or remove if so


@defproc/nolink[(make-string-input-port [string string?]) port?]{
Returns a port that reads characters from the supplied string.
}

@deftogether[(@defproc/nolink[(make-string-output-port) port?]
              @defproc/nolink[(string-output-port-output [port port?]) string?])]{
A string output port is a port that collects the characters given to it into a string. The
accumulated string is retrieved by applying @code{string-output-port-output} to the port.
}

@defproc/nolink[(call-with-string-output-port [procedure (-> port? any)]) string?]{
The @var{procedure} value is called on a port. When it returns, @code{call-with-string-output-port}
returns a string containing the characters that were written to that port during the execution of
@var{procedure}.
}

@subsection{Revealed Ports and File Descriptors}

The material in this section and the following one is not critical for most applications. You may
safely skim or completely skip this section on a first reading.

Dealing with Unix file descriptors in a Scheme environment is difficult. In Unix, open files are
part of the process environment, and are referenced by small integers called
@emph{file descriptors}. Open file descriptors are the fundamental way I/O redirections are passed
to subprocesses, since file descriptors are preserved across fork's and exec's.

Scheme, on the other hand, uses ports for specifying I/O sources. Ports are garbage-collected Scheme
objects, not integers. Ports can be garbage collected; when a port is collected, it is also closed.
Because file descriptors are just integers, it's impossible to garbage collect them---you wouldn't
be able to close file descriptor 3 unless there were no 3's in the system, and you could further
prove that your program would never again compute a 3. This is difficult at best.

If a Scheme program only used Scheme ports, and never actually used file descriptors, this would not
be a problem. But Scheme code must descend to the file descriptor level in at least two
circumstances:

@itemlist[@item{when interfacing to foreign code}
          @item{when interfacing to a subprocess}]

This causes a problem. Suppose we have a Scheme port constructed on top of file descriptor 2. We
intend to fork off a program that will inherit this file descriptor. If we drop references to the
port, the garbage collector may prematurely close file 2 before we fork the subprocess. The
interface described below is intended to fix this and other problems arising from the mismatch
between ports and file descriptors.

The scsh kernel maintains a port table that maps a file descriptor to the scheme port allocated for
it (or, #f if there is no port allocated for this file descriptor). This is used to ensure that
there is at most one open port for each open file descriptor.

Conceptually, the port data structure for file ports has two fields besides the descriptor:
@var{revealed} and @var{closed?}. When a file port is closed with @code{(close port)}, the port's
file descriptor is closed, its entry in the port table is cleared, and the port's @var{closed?}
field is set to true.

When a file descriptor is closed with @code{(close fdes)}, any associated port is shifted to a new
file descriptor created with @code{(dup fdes)}. The port has its revealed count reset to zero (and
hence becomes eligible for closing on GC). See discussion below. To really put a stake through a
descriptor's heart without waiting for associated ports to be GC'd, you must say one of

@codeblock{(close (fdes->inport fdes))
           (close (fdes->output fdes))}

The @var{revealed} field is an aid to garbage collection. It is an integer semaphore. If it is zero,
the port's file descriptor can be closed when the port is collected. Essentially, the @var{revealed}
field reflects whether or not the port's file descriptor has escaped to the scheme user. If the
scheme user doesn't know what file descriptor is associated with a given port, then he can't
possibly retain an ``integer handle'' on the port after dropping pointers to the port itself, so the
garbage collector is free to close the file.

Ports allocated with @code{open-output-file} and @code{open-input-file} are unrevealed ports---i.e.,
@var{revealed} is initialised to 0. No one knows the port's file descriptor, so the file descriptor
can be closed when the port is collected.

The functions @code{fdes->output-port}, @code{fdes->input-port}, @code{port->fdes} are used to shift
back and forth between file descriptors and ports.  When @code{port->fdes} reveals a port's file
descriptor, it increments the port's @var{revealed} field.  When the user is through with the file
descriptor, he can call @code{(release-port-handle port)}, which decrements the count. The function
@code{(call/fdes fd/port proc)} automates this protocol. @code{call/fdes} uses @code{dynamic-wind}
to enforce the protocol. If @var{proc} throws out of the @code{call/fdes} application, the unwind
handler releases the descriptor handle; if the user subsequently tries to throw @emph{back} into
@var{proc}'s context, the wind handler raises an error. When the user maps a file descriptor to a
port with @code{fdes->outport} or @code{fdes->inport}, the port has its revealed field incremented.

Not all file descriptors are created by requests to make ports.  Some are inherited on process
invocation via
@hyperlink["http://www.FreeBSD.org/cgi/man.cgi?query=exec&apropos=0&sektion=0&manpath=FreeBSD+4.3-RELEASE&format=html"]{exec(2)}},
and are simply part of the global environment. Subprocesses may depend upon them, so if a port is
later allocated for these file descriptors, is should be considered as a revealed port. For example,
when the scheme shell's process starts up, it opens ports on file descriptors 0, 1, and 2 for the
initial values of @code{(current-input-port)}, @code{(current-output-port)}, and
@code{(error-output-port)}. These ports are initialised with @var{revealed} set to 1, so that stdin,
stdout, and stderr are not closed even if the user drops the port.

Unrevealed file ports have the nice property that they can be closed when all pointers to the port
are dropped. This can happen during gc, or at an @code{exec()}---since all memory is dropped at an
@code{exec()}. No one knows the file descriptor associated with the port, so the exec'd process
certainly can't refer to it.

This facility preserves the transparent close-on-collect property for file ports that are used in
straightforward ways, yet allows access to the underlying Unix substrate without interference from
the garbage collector. This is critical, since shell programming absolutely requires access to the
Unix file descriptors, as their numerical values are a critical part of the process interface.

A port's underlying file descriptor can be shifted around with @code{dup(2)} when convenient. That
is, the actual file descriptor on top of which a port is constructed can be shifted around
underneath the port by the scsh kernel when necessary.  This is important, because when the user is
setting up file descriptors prior to a @code{exec(2)}, he may explicitly use a file descriptor that
has already been allocated to some port. In this case, the scsh kernel just shifts the port's file
descriptor to some new location with @code{dup}, freeing up its old descriptor.  This prevents
errors from happening in the following scenario.  Suppose we have a file open on port @var{f}.  Now
we want to run a program that reads input on file 0, writes output to file 1, errors to file 2, and
logs execution information on file 3. We want to run this program with input from @code{f}. So we
write:

@codeblock{(run (/usr/shivers/bin/prog)
                (> 1 output.txt)
                (> 2 error.log)
                (> 3 trace.log)
                (= 0 ,f))}

Now, suppose by ill chance that, unbeknownst to us, when the operating system opened @code{f}'s
file, it allocated descriptor 3 for it. If we blindly redirect @code{trace.log} into file descriptor
3, we'll clobber @code{f}! However, the port-shuffling machinery saves us: when the @code{run} form
tries to dup @code{trace.log}'s file descriptor to 3, @code{dup} will notice that file descriptor 3
is already associated with an unrevealed port (i.e., @code{f}). So, it will first move @code{f} to
some other file descriptor. This keeps @code{f} alive and well so that it can subsequently be dup'd
into descriptor 0 for @code{prog}'s stdin.

The port-shifting machinery makes the following guarantee: a port is only moved when the underlying
file descriptor is closed, either by a @code{close()} or a @code{dup2()} operation. Otherwise a
port/file-descriptor association is stable.

Under normal circumstances, all this machinery just works behind the scenes to keep things
straightened out. The only time the user has to think about it is when he starts accessing file
descriptors from ports, which he should almost never have to do. If a user starts asking what file
descriptors have been allocated to what ports, he has to take responsibility for managing this
information.

@subsection{Port-Mapping Machinery}

The procedures provided in this section are almost never needed. You may safely skim or completely
skip this section on a first reading.

Here are the routines for manipulating ports in scsh. The important points to remember are:

@itemlist[@item{A file port is associated with an open file, not a particular file descriptor.}
          @item{The association between a file port and a particular file descriptor is never
                changed @emph{except} when the file descriptor is explicitly closed. ``Closing''
                includes being used as the target of a @code{dup2}, so the set of procedures below
                that close their targets are @code{close}, two-argument @code{dup}, and
                @code{move->fdes}. If the target file descriptor of one of these routines has an
                allocated port, the port will be shifted to another freshly-allocated file
                descriptor, and marked as unrevealed, thus preserving the port but freeing its old
                file descriptor.}]

These rules are what is necessary to ``make things work out'' with no surprises in the general case.

@deftogether[(@defproc/nolink[(fdes->inport [fd integer?]) port?]
              @defproc/nolink[(fdes->outport [fd integer?]) port?])]{
These guys return an input or output port respecitvely, backed by @var{fd}. The returned port has
its revealed count set to 1.
}

@; will need to export fdport? if we use it as a predicate here.
@defproc/nolink[(port->fdes [port fdport?]) integer?]{
Returns the file descriptor backing @var{port} and increments its revealed count by 1.
}

@defproc/nolink[(port-revealed [port fdport?]) (or/c integer? #f)]{
Return the port's revealed count if positive, otherwise #f.
}

@defproc/nolink[(release-port-handle [port fdport?]) undefined]{
Decrement @var{port}'s revealed count.
}

@defproc/nolink[(call/fdes [fd/port (or/c integer? fdport?)]
                                      [consumer (-> integer? any)]) any]{
Calls @var{consumer} on a file descriptor; takes care of revealed bookkeeping. If @var{fd/port} is a
file descriptor, this is just @code{(consumer fd/port)}. If @var{fd/port} is a port, calls
@var{consumer} on its underlying file descriptor. While @var{consumer} is running, the port's
revealed count is incremented.

When @code{call/fdes} is called with port argument, you are not allowed to throw into @var{consumer}
with a stored continuation, as that would violate the revealed-count bookkeeping.
}

@defproc/nolink[(move->fdes [fd/port (or/c integer? fdport?)] [target-fd integer?])
         (or/c integer? fdport?)]{
Maps fd -> fd and port ->port.

If @var{fd/port} is a file-descriptor not equal to @var{target-fd}, dup it to @var{target-fd} and
close it. Returns @var{target-fd}.

If @var{fd/port} is a port, it is shifted to @var{target-fd}, by duping its underlying
file-descriptor if necessary. @var{fd/port}'s original file descriptor is closed (if it was
different from @var{target-fd}). Returns the port. This operation resets @var{fd/port}'s revealed
count to 1.

In all cases when @var{fd/port} is actually shifted, if there is a port already using
@var{target-fd}, it is first relocated to some other file descriptor.
}

@subsection{Unix I/O}
@deftogether[(@defproc*[#:link-target? #f
                        ([(dup [fd/port (or/c integer? fdport?)]) fdport?]
                         [(dup [fd/port (or/c integer? fdport?)] [newfd integer?]) fdport?])]
              @defproc*[#:link-target? #f
                        ([(dup->inport [fd/port (or/c integer? fdport?)]) fdport?]
                         [(dup->inport [fd/port (or/c integer? fdport?)] [newfd integer?]) fdport?])]
              @defproc*[#:link-target? #f
                        ([(dup->outport [fd/port (or/c integer? fdport?)]) fdport?]
                         [(dup->outport [fd/port (or/c integer? fdport?)] [newfd integer?]) fdport?])]
              @defproc*[#:link-target? #f
                        ([(dup->fdes [fd/port (or/c integer? fdport?)]) integer?]
                         [(dup->fdes [fd/port (or/c integer? fdport?)] [newfd integer?]) integer?])])]{
These procedures provide the functionality of C's @code{dup()} and @code{dup2()}. The different
routines return different types of values: @code{dup->inport}, @code{dup->outport}, and
@code{dup->fdes} return input ports, output ports, and integer file descriptors, respectively.
@code{dup}'s return value depends on on the type of @var{fd/port}---it maps fd -> fd and port ->
port.

These procedures use the Unix @code{dup()} syscall to replicate the file descriptor or file port
@var{fd/port}. If a @var{newfd} file descriptor is given, it is used as the target of the dup
operation, i.e., the operation is a @code{dup2()}. In this case, procedures that return a port (such
as @code{dup->inport}) will return one with the revealed count set to one. For example,
@code{(dup (current-input-port) 5)} produces a new port with underlying file descriptor 5, whose
revealed count is 1. If @var{newfd} is not specified, then the operating system chooses the file
descriptor, and any returned port is marked as unrevealed.

If the @var{newfd} target is given, and some port is already using that file descriptor, the port is
first quietly shifted (with another @code{dup}) to some other file descriptor (zeroing its revealed
count).

Since scheme doesn't provide read/write ports, @code{dup->inport} and @code{dup->outport} can be
useful for getting an output version of an input port, or @emph{vice versa}.  For example, if
@code{p} is an input port open on a tty, and we would like to do output to that tty, we can simply
use @code{(dup->outport p)} to produce an equivalent output port for the tty. Be sure to open the
file with the @code{open/read+write} flag for this.
}

@defproc*[#:link-target? #f
          ([(seek [fd integer?] [offset integer?]) integer?]
           [(seek [fd integer?] [offset integer?] [whence integer?]) integer?])]{
Reposition the I/O cursor for a file descriptor. @var{whence} is one of @code{seek/set},
@code{seek/delta}, or @code{seek/end}, and defaults to @code{seek/set}. If @code{seek/set}, then
@var{offset} is an absolute index into the file; if @code{seek/delta}, then @var{offset} is a
relative offset from the current I/O cursor; if @code{seek/end}, then @var{offset} is a relative
offset from the end of file. Note that not all file descriptors are seekable; this is dependent on
the OS implementation. The return value is the resulting position of the I/O cursor in the I/O
stream.
}

@defproc/nolink[(tell [fd integer?]) integer?]{
Returns the position of the I/O cursor in the the I/O stream. Not all file descriptors support
cursor-reporting; this is dependent on the OS implementation.
}

@defproc/nolink[(open-file [fname string?] [options file-options?] [mode file-mode? (filemode read write)]) fdport?]{
@var{options} is a file-option? (ref). You must use exactly one of the options @code{read-only},
@code{write-only}, or @code{read-write}. The returned port is an input port if the @var{options}
permit it, otherwise an output port. scheme48/scsh do not have input/output ports, so it's one
or the other. You can hack simultaneous I/O on a file by opening it r/w, taking the result input
port, and duping it to an output port with @code{dup->outport}.
}

@deftogether[(@defproc/nolink[(open-input-file [fname string?] [options file-options? (file-options)]) port?]
              @defproc/nolink[(open-output-file [fname string?]
                                                           [options file-options? (file-options create truncate)]
                                                           [mode file-mode? (filemode read write)]) port?])]{
These are equivalent to @code{open-file}, after first including @code{read-only} or
@code{write-only} options, respectively, in the @var{options} argument. The default values for
@var{options} make the procedures backwards-compatible with their unary RnRS definitions.
}

@defproc/nolink[(pipe) (values [rport fdport?] [wport fdport?])]{
Returns two ports @var{rport} and @var{wport}, the read and write endpoints respectively of a Unix
pipe.
}

@subsection{Buffered I/O}

@defproc/nolink[(force-output [fd/port (or/c integer? fdport?)]) undefined]{
This procedure does nothing when applied to an integer file descriptor. It flushes buffered output
when applied to a port, and raises a write-error exception on error. Returns no value.
}

@defproc/nolink[(flush-all-ports) undefined]{
This procedure flushes all open output ports with buffered data.
}

@section{Filesystem}
Besides the procedures in this section, which allow access to the computer's file system, scsh also
provides a set of procedures which manipulate file @emph{names}. These string-processing procedures
are documented in @; TODO @secref["manipulating-filenames"]

@deftogether[(@defproc/nolink[(create-directory [fname string?] [mode file-mode? (file-mode all)] [override? (or/c #f 'query any/c) #f]) undefined]
              @defproc/nolink[(create-fifo [fname string?] [mode file-mode? (file-mode all)] [override? (or/c #f 'query any/c) #f]) undefined]
              @defproc/nolink[(create-hard-link [oldname string?] [newname string?] [override? (or/c #f 'query any/c) #f]) undefined]
              @defproc/nolink[(create-symlink [oldname string?] [newname string?] [override? (or/c #f 'query any/c) #f]) undefined])]{
These procedures create objects of various kinds in the file system. The @var{override?} argument
controls the action if there is already an object in the file system with the new name:

@tabular[#:sep @hspace[2]
         (list (list @code{#f} @nested{signal an error (default)})
               (list @code{'query} @nested{prompt the user})
               (list @emph{other} @nested{delete the old object (with @code{delete-file} or
                                          @code{delete-directory} as appropriate) before creating
                                          the new object}))]

@var{mode} defaults to @code{(file-mode all)} (but is masked by the current umask).
}

@deftogether[(@defproc/nolink[(delete-directory [fname string?]) undefined]
              @defproc/nolink[(delete-file [fname string?]) undefined]
              @defproc/nolink[(delete-filesys-object [fname string?]) undefined])]{
These procedures delete objects from the filesystem. The @code{delete-filesys-object} procedure will
delete an object of any type from the file system: files, (empty) directories, symlinks, fifos, etc.

If the object being deleted doesn't exist, @code{delete-directory} and @code{delete-file} raise an
error, while delete-filesys-object simply returns.
}

@defproc/nolink[(read-symlink [fname string?]) string?]{
Return the filename referenced by the symbolic link @var{fname}.
}

@margin-note{There is an unfortunate atomicity problem with the @code{rename-file} procedure: if you
             specify no-override, but create file @var{new-fname} sometime between
             @code{rename-file}'s existence check and the actual rename operation, your file will be
             clobbered with @var{old-fname}. There is no way to fix this problem, given the
             semantics of Unix @code{rename()}; at least it is highly unlikely to occur in
             practice.}

@defproc/nolink[(rename-file [old-fname string?] [new-fname string?] [override? (or/c #f 'query any/c) #f]) undefined]{
If you override an existing object, then @var{old-fname} and @var{new-fname} must
type-match---either both directories, or both non-directories. This is required by the semantics of
Unix @code{rename()}.
}

@deftogether[(@defproc/nolink[(set-file-mode [fname/fd/port (or/c string? integer? fdport?)] [mode file-mode?]) undefined]
              @defproc/nolink[(set-file-owner [fname/fd/port (or/c string? integer? fdport?)] [uid integer?]) undefined]
              @defproc/nolink[(set-file-group [fname/fd/port (or/c string? integer? fdport?)] [gid integer?]) undefined])]{
These procedures set the permission bits, owner id, and group id of a file, respectively. The file
can be specified by giving the file name, or either an integer file descriptor or a port open on the
file. Setting file user ownership usually requires root privileges.
}

@defproc/nolink[(set-file-times [fname string?]
                                           [access-time integer? (current-time)]
                                           [mod-time integer? (current-time)]) undefined]{
@var{fname} to the supplied values (see (link to sec:time) for the scsh representation of time). If
neither time argument is supplied, they are both taken to be the current time. You must provide both
times or neither. If the procedure completes successfully, the file's time of last status-change
(@code{ctime}) is set to the current time.
}

@margin-note{These procedures are not Posix. Their actual effect may vary between operating systems.
             See your OS's documentation for @code{sync(2)} and @code{fsync(2)} respectively for
             specifics}

@deftogether[(@defproc/nolink[(sync-file [fd/port (or/c integer? fdport?)]) undefined]
              @defproc/nolink[(sync-file-system) undefined])]{
Calling @code{sync-file} causes Unix to update the disk data structures for a given file. If
@var{fd/port} is a port, any buffered data it may have is first flushed. Calling
@code{sync-file-system} synchronises the kernel's entire file system with the disk.
}

@defproc/nolink[(truncate-file [fname/fd/port (or/c string? integer? fdport?)] [len integer?]) undefined]{
Truncate the specified file to @var{len} bytes in length.
}

@defproc/nolink[(file-info [fname/fd/port (or/c string? integer? fdport?)] [chase? any/c #t]) file-info?]{
Returns a record structure containing everything there is to know about a file. If the @var{chase?}
flag is true (the default), then the procedure chases symlinks and reports on the files to which
they refer. If @var{chase?} is false, then the procedure checks the actual file itself, even if it's
a symlink. The @var{chase?} flag is ignored if the file argument is a file descriptor or port.

The value returned is a @emph{file-info record}, whose accessors are defined in this chapter.
}

@defproc/nolink[(file-info:type [finfo file-info?])
         (or/c 'block-special 'char-special 'directory 'fifo 'regular 'socket 'symlink)]{
Returns a symbol denoting the type of the file described by @var{finfo}.
}

@defproc/nolink[(file-info:device [finfo file-info?]) integer?]{
Returns an integer denoting the device that the file described by @var{finfo} resides on.
}

@defproc/nolink[(file-info:inode [finfo file-info?]) integer?]{
Returns an integer denoting the file system inode that points to the file described by @var{finfo}.
}

@defproc/nolink[(file-info:mode [finfo file-info?]) file-mode?]{
Returns a file-mode object describing the permissions set on the file described by @var{finfo}.
}

@defproc/nolink[(file-info:nlinks [finfo file-info?]) integer?]{
Returns the number of hard links to the file described by @var{finfo}.
}

@defproc/nolink[(file-info:uid [finfo file-info?]) integer?]{
Returns user id of the owner of the file file described by @var{finfo}.
}

@defproc/nolink[(file-info:gid [finfo file-info?]) integer?]{
Returns the group id of the file described by @var{finfo}.
}

@defproc/nolink[(file-info:size [finfo file-info?]) integer?]{
Returns the size in bytes of the file described by @var{finfo}.
}

@defproc/nolink[(file-info:size [finfo file-info?]) integer?]{
Returns the time at which the file described by @var{finfo} was last accessed.
}

@defproc/nolink[(file-info:atime [finfo file-info?]) integer?]{
Returns the time at which the file described by @var{finfo} was last accessed.
}

@defproc/nolink[(file-info:mtime [finfo file-info?]) integer?]{
Returns the time at which the file described by @var{finfo} was last modified.
}

@defproc/nolink[(file-info:ctime [finfo file-info?]) integer?]{
Returns the time at which the file described by @var{finfo} last had its status changed.
}

@deftogether[(@defproc/nolink[(file:type [fname/fd/port (or/c string? integer? fdport?)] [chase? any/c #t])
                       (or/c 'block-special 'char-special 'directory 'fifo 'regular 'socket 'symlink)]
              @defproc/nolink[(file:device [fname/fd/port (or/c string? integer? fdport?)] [chase? any/c #t]) integer?]
              @defproc/nolink[(file:inode [fname/fd/port (or/c string? integer? fdport?)] [chase? any/c #t]) integer?]
              @defproc/nolink[(file:mode [fname/fd/port (or/c string? integer? fdport?)] [chase? any/c #t]) file-mode?]
              @defproc/nolink[(file:nlinks [fname/fd/port (or/c string? integer? fdport?)] [chase? any/c #t]) integer?]
              @defproc/nolink[(file:uid [fname/fd/port (or/c string? integer? fdport?)] [chase? any/c #t]) integer?]
              @defproc/nolink[(file:gid [fname/fd/port (or/c string? integer? fdport?)] [chase? any/c #t]) integer?]
              @defproc/nolink[(file:size [fname/fd/port (or/c string? integer? fdport?)] [chase? any/c #t]) integer?]
              @defproc/nolink[(file:atime [fname/fd/port (or/c string? integer? fdport?)] [chase? any/c #t]) integer?]
              @defproc/nolink[(file:mtime [fname/fd/port (or/c string? integer? fdport?)] [chase? any/c #t]) integer?]
              @defproc/nolink[(file:ctime [fname/fd/port (or/c string? integer? fdport?)] [chase? any/c #t]) integer?])]{
These procuders are a composition of @code{file-info} and its accessors. They allow more convenient
access to file based information, without handling an intermediary file-info object.
}

@deftogether[(@defproc/nolink[(file-directory? [fname/fd/port (or/c string? integer? fdport?)] [chase? any/c #t]) boolean?]
              @defproc/nolink[(file-fifo? [fname/fd/port (or/c string? integer? fdport?)] [chase? any/c #t]) boolean?]
              @defproc/nolink[(file-regular? [fname/fd/port (or/c string? integer? fdport?)] [chase? any/c #t]) boolean?]
              @defproc/nolink[(file-socket? [fname/fd/port (or/c string? integer? fdport?)] [chase? any/c #t]) boolean?]
              @defproc/nolink[(file-special? [fname/fd/port (or/c string? integer? fdport?)] [chase? any/c #t]) boolean?]
              @defproc/nolink[(file-symlink? [fname/fd/port (or/c string? integer? fdport?)]) boolean?])]{
These procedures are file-type predicates that test the type of a given file. They are applied to
the same arguments to which @code{file-info} is applied; the sole exception is @code{file-symlink?},
which does not take the optional @var{chase?} second argument.
}

@deftogether[(@defproc/nolink[(file-info-directory? [file-info file-info?]) boolean?]
              @defproc/nolink[(file-info-fifo? [file-info file-info?]) boolean?]
              @defproc/nolink[(file-info-regular? [file-info file-info?]) boolean?]
              @defproc/nolink[(file-info-socket? [file-info file-info?]) boolean?]
              @defproc/nolink[(file-info-special? [file-info file-info?]) boolean?]
              @defproc/nolink[(file-info-symlink? [file-info file-info?]) boolean?])]{
These are variants of the file-type predicates which work directly on @code{file-info} records.
}

@deftogether[(@defproc/nolink[(file-not-readable? [fname/fd/port (or/c string? integer? fdport?)])
                       (or/c #f 'search-denied 'permission 'no-directory 'nonexistent)]
              @defproc/nolink[(file-not-writable? [fname/fd/port (or/c string? integer? fdport?)])
                       (or/c #f 'search-denied 'permission 'no-directory 'nonexistent)]
              @defproc/nolink[(file-not-executable? [fname/fd/port (or/c string? integer? fdport?)])
                       (or/c #f 'search-denied 'permission 'no-directory 'nonexistent)])]{
This set of procedures are a convenient means to work on the permission bits of a file. The meaning
of their return values are as follows:

@tabular[#:sep @hspace[2]
         (list (list @code{#f} @nested{Access permitted})
               (list @code{'search-denied} @nested{Can't stat --- a protected directory is blocking access})
               (list @code{'permission} @nested{Permission denied.})
               (list @code{'no-directory} @nested{Some directory doesn't exist.})
               (list @code{'nonexistent} @nested{File doesn't exist.}))]

A file is considered writeable if either (1) it exists and is writeable or (2) it doesn't exist and
the directory is writeable. Since symlink permission bits are ignored by the filesystem, these calls
do not take a @var{chase?} flag.

Note that these procedures use the process' @emph{effective} user and group ids for permission
checking. Posix defines an @code{access()} function that uses the process' real uid and gids. This
is handy for setuid programs that would like to find out if the actual user has specific rights;
scsh ought to provide this functionality (but doesn't at the current time).

There are several problems with these procedures. First, there's an atomicity issue. In between
checking permissions for a file and then trying an operation on the file, another process could
change the permissions, so a return value from these functions guarantees nothing. Second, the code
special-cases permission checking when the uid is root---if the file exists, root is assumed to have
the requested permission. However, not even root can write a file that is on a read-only file
system, such as a CD ROM. In this case, @code{file-not-writable?} will lie, saying that root has
write access, when in fact the opening the file for write access will fail. Finally, write
permission confounds write access and create access. These should be disentangled.

Some of these problems could be avoided if Posix had a real-uid variant of the @code{access()} call
we could use, but the atomicity issue is still a problem. In the final analysis, the only way to
find out if you have the right to perform an operation on a file is to try and open it for the
desired operation. These permission-checking functions are mostly intended for script-writing, where
loose guarantees are tolerated.
}

@deftogether[(@defproc/nolink[(file-readable? [fname/fd/port (or/c string? integer? fdport?)]) boolean?]
              @defproc/nolink[(file-writable? [fname/fd/port (or/c string? integer? fdport?)]) boolean?]
              @defproc/nolink[(file-executable? [fname/fd/port (or/c string? integer? fdport?)]) boolean?])]{
These procedures are the logical negation of the preceding @code{file-not-}* procedures. Refer to those
for a discussion of their problems and limitations. These procedures will only ever return @code{#t}
or @code{#f}, and not the symbols giving specific reasons.
}

@deftogether[(@defproc/nolink[(file-info-not-readable? [file-info file-info?]) boolean?]
              @defproc/nolink[(file-info-not-writable? [file-info file-info?]) boolean?]
              @defproc/nolink[(file-info-not-executable? [file-info file-info?]) boolean?]
              @defproc/nolink[(file-info-readable? [file-info file-info?]) boolean?]
              @defproc/nolink[(file-info-writable? [file-info file-info?]) boolean?]
              @defproc/nolink[(file-info-executable? [file-info file-info?]) boolean?])]{
There are variants of the file permission predicates which work directly on @code{file-info}
records.
}

@deftogether[(@defproc/nolink[(file-not-exists? [fname/fd/port (or/c string? integer? fdport?)]) (or/c boolean? 'search-denied)]
              @defproc/nolink[(file-exists? [fname/fd/port (or/c string? integer? fdport?)]) boolean?])]{
The meaning of the return values of @code{file-not-exists?} are as follows:

@tabular[#:sep @hspace[2]
         (list (list @code{#f} @nested{Exists})
               (list @code{#t} @nested{Doesn't exist.})
               (list @code{'search-denied} @nested{Some protected directory is blocking the search.}))]

@code{file-exists?} is simply the logical negation of @code{file-not-exists?}.
}

@defproc/nolink[(directory-files [dir string? (cwd)] [dotfiles? boolean? #f]) (listof string?)]{
Return the list of files in directory @var{dir}, which defaults to the current working directory.
The @var{dotfiles?} flag causes dot files to be included in the list. Regardless of the value of
@var{dotfiles?}, the two files @code{"."} and @code{".."} are @emph{never} returned.

The directory @var{dir} is not prepended to each file name in the result list. That is,

@codeblock{(directory-files "/etc")}

returns

@codeblock{("chown" "exports" "fstab" ...)}

@emph{not}

@codeblock{("/etc/chown" "/etc/exports" "/etc/fstab" ...)}

To use the files in returned list, the programmer can either manually prepend the directory:

@codeblock{(map (lambda (f) (string-append dir "/" f)) files)}

or cd to the directory before using the file names:

@codeblock{(with-cwd dir
             (for-each delete-file (directory-files)))}

or use the @code{glob} procedure, defined in this chapter.

A directory list can be generated by @code{(run/strings (ls))}, but this is unreliable, as
filenames with whitespace in their names will be split into separate entries.
@code{directory-files} is reliable.
}

@deftogether[(@defproc/nolink[(open-directory-stream [dir string?]) directory-stream?]
              @defproc/nolink[(directory-stream? [maybe-directory-stream any/c]) boolean?]
              @defproc/nolink[(read-directory-stream [directory-stream directory-stream?]) (or/c string? #f)]
              @defproc/nolink[(close-directory-stream [directory-stream directory-stream?]) undefined])]{
These functions implement a direct interface to the @code{opendir()} / @code{readdir()} /
@code{closedir()} family of functions for processing directory streams.
@code{(open-directory-stream dir)} creates a stream of files in the directory @var{dir}.
@code{directory-stream?} is a predicate that recognizes directory-streams.
@code{(read-directory-stream directory-stream)} returns the next file in the stream or @code{#f} if
no such file exists. Finally, @code{(close-directory-stream directory-stream)} closes the stream.
}

@defproc/nolink[(glob [pattern string?] ...) (listof string)]{
@margin-note{Why bother to mention such a silly possibility? Because that is what sh does.}
Glob each pattern against the filesystem and return the sorted list. Duplicates are not removed.
Patterns matching nothing are not included literally.

C shell {a,b,c} patterns are expanded. Backslash quotes characters, turning off the
special meaning of {, }, @code{*}, [, ], and ?.

Note that the rules of backslash for Scheme strings and glob patterns work together to require four
backslashes in a row to specify a single literal backslash. Fortunately, it is very rare that a
backslash occurs in a Unix file name.

A glob subpattern will not match against dot files unless the first character of the subpattern is a
literal ".". Further, a dot subpattern will not match the files @code{"."} or @code{".."}
unless it is a constant pattern, as in @code{(glob "../*/*.c")}. So a directory's dot files can be
reliably generated with the simple glob pattern @code{".*"}.

Some examples.

All the C and #include files in my directory:
@codeblock{(glob "*.c" "*.h")}

All the C files in this directory and its immediate subdirectories:
@codeblock{(glob "*.c" "*/*.c")}

All the C files in the lexer and parser dirs:
@codeblock{(glob "lexer/*.c" "parser/*.c")
           (glob "{lexer,parser}/*.c")}

All the C files in the strange directory @code{"{lexer,parser}"}:
@codeblock{(glob "\\{lexer,parser\\}/*.c")}

All the files ending in @code{"*"}, e.g. @code{("foo*" "bar*")}:
@codeblock{(glob "*\\*")}

All files containing the string @code{"lexer"}, e.g. @code{("mylexer.c" "lexer1.notes")}:
@codeblock{(glob "*lexer*")}

Either @code{("lexer")} or @code{()}:
@codeblock{(glob "lexer")}

If the first character of the pattern (after expanding braces) is a slash, the search begins at
root; otherwise, the search begins in the current working directory.

If the last character of the pattern (after expanding braces) is a slash, then the result matches
must be directories, e.g.

@codeblock{(glob "/usr/man/man?/") => ("/usr/man/man1/" "/usr/man/man2/" ...)}

Globbing can sometimes be useful when we need a list of a directory's files where each element in
the list includes the pathname for the file.

Compare:
@codeblock{(directory-files "../include") => ("cig.h" "decls.h" ...)}

@codeblock{(glob "../include/*") => ("../include/cig.h" "../include/decls.h" ...)}
}

@defproc/nolink[(glob-quote [pattern string?]) string?]{
Returns a constant glob pattern that exactly matches @var{pattern}. All wild-card characters in
@var{pattern} are quoted with a backslash.

@codeblock{(glob-quote "Any *.c files?") => "Any \\*.c files\\?"}
}
